package com.pesitwizard.security;

import static org.assertj.core.api.Assertions.*;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

/**
 * Unit tests for SecretsTracing.
 */
@DisplayName("SecretsTracing Tests")
class SecretsTracingTest {

    private SecretsTracing tracing;

    @BeforeEach
    void setUp() {
        tracing = new SecretsTracing();
    }

    @Nested
    @DisplayName("Trace with Supplier")
    class TraceSupplierTests {

        @Test
        @DisplayName("should execute and return result from supplier")
        void shouldExecuteAndReturnResult() {
            String result = tracing.trace("encrypt", "AES", () -> "encrypted-value");

            assertThat(result).isEqualTo("encrypted-value");
        }

        @Test
        @DisplayName("should execute supplier that returns null")
        void shouldExecuteSupplierReturningNull() {
            String result = tracing.trace("decrypt", "VAULT", () -> null);

            assertThat(result).isNull();
        }

        @Test
        @DisplayName("should propagate exception from supplier")
        void shouldPropagateExceptionFromSupplier() {
            assertThatThrownBy(() -> tracing.trace("encrypt", "AES", () -> {
                throw new RuntimeException("Encryption failed");
            })).isInstanceOf(RuntimeException.class)
                    .hasMessage("Encryption failed");
        }

        @Test
        @DisplayName("should execute with different providers")
        void shouldExecuteWithDifferentProviders() {
            String aesResult = tracing.trace("encrypt", "AES", () -> "aes-encrypted");
            String vaultResult = tracing.trace("encrypt", "VAULT", () -> "vault-encrypted");

            assertThat(aesResult).isEqualTo("aes-encrypted");
            assertThat(vaultResult).isEqualTo("vault-encrypted");
        }

        @Test
        @DisplayName("should handle long-running operations")
        void shouldHandleLongRunningOperations() {
            String result = tracing.trace("slowOperation", "AES", () -> {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                return "completed";
            });

            assertThat(result).isEqualTo("completed");
        }
    }

    @Nested
    @DisplayName("Trace Void")
    class TraceVoidTests {

        @Test
        @DisplayName("should execute runnable")
        void shouldExecuteRunnable() {
            StringBuilder sb = new StringBuilder();

            tracing.traceVoid("storeSecret", "VAULT", () -> sb.append("executed"));

            assertThat(sb.toString()).isEqualTo("executed");
        }

        @Test
        @DisplayName("should propagate exception from runnable")
        void shouldPropagateExceptionFromRunnable() {
            assertThatThrownBy(() -> tracing.traceVoid("deleteSecret", "VAULT", () -> {
                throw new RuntimeException("Delete failed");
            })).isInstanceOf(RuntimeException.class)
                    .hasMessage("Delete failed");
        }
    }

    @Nested
    @DisplayName("SpanContext Record")
    class SpanContextTests {

        @Test
        @DisplayName("should create SpanContext with auto-generated IDs")
        void shouldCreateSpanContextWithAutoGeneratedIds() {
            SecretsTracing.SpanContext context = SecretsTracing.SpanContext.create();

            assertThat(context.traceId()).isNotNull().isNotEmpty();
            assertThat(context.spanId()).isNotNull().isNotEmpty();
            assertThat(context.parentSpanId()).isNull();
        }

        @Test
        @DisplayName("should create unique trace IDs")
        void shouldCreateUniqueTraceIds() {
            SecretsTracing.SpanContext context1 = SecretsTracing.SpanContext.create();
            SecretsTracing.SpanContext context2 = SecretsTracing.SpanContext.create();

            assertThat(context1.traceId()).isNotEqualTo(context2.traceId());
        }

        @Test
        @DisplayName("should create SpanContext with custom values")
        void shouldCreateSpanContextWithCustomValues() {
            SecretsTracing.SpanContext context = new SecretsTracing.SpanContext(
                    "trace-123", "span-456", "parent-789");

            assertThat(context.traceId()).isEqualTo("trace-123");
            assertThat(context.spanId()).isEqualTo("span-456");
            assertThat(context.parentSpanId()).isEqualTo("parent-789");
        }

        @Test
        @DisplayName("trace ID should have no dashes")
        void traceIdShouldHaveNoDashes() {
            SecretsTracing.SpanContext context = SecretsTracing.SpanContext.create();

            assertThat(context.traceId()).doesNotContain("-");
        }
    }
}
